<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Calendar Puzzle</title>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@500;600;700&family=Lora:ital,wght@0,400;0,500;1,400&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#F2EDE3;--board-bg:#E6D9C0;--board-border:#7A5C30;
    --cell-text:#3A2A10;--cell-border:#C8AA76;
    --selected-ring:#D4601A;--target-color:#D4B017;
    --cs:60px;
  }
  *{box-sizing:border-box;margin:0;padding:0;-webkit-tap-highlight-color:transparent}
  html,body{overscroll-behavior:none}
  body{
    background:var(--bg);font-family:'Lora',Georgia,serif;
    min-height:100vh;display:flex;flex-direction:column;align-items:center;
    padding:14px 10px 32px;
    background-image:radial-gradient(ellipse at 20% 10%,rgba(200,160,80,.08) 0%,transparent 60%),
                     radial-gradient(ellipse at 80% 90%,rgba(160,100,40,.07) 0%,transparent 60%);
  }
  h1{font-family:'Playfair Display',serif;color:#3A2A10;font-size:clamp(1.3rem,5vw,2.1rem);
    margin-bottom:2px;letter-spacing:.03em;text-shadow:0 1px 3px rgba(100,60,10,.12);text-align:center}
  .subtitle{color:#7A5C30;font-size:clamp(.72rem,.9rem,1rem);margin-bottom:8px;font-style:italic;text-align:center;padding:0 8px}
  
  /* Date picker */
  .date-picker-row{display:flex;align-items:center;justify-content:center;gap:8px;margin-bottom:12px;flex-wrap:wrap}
  .date-btn{
    background:rgba(255,255,255,.5);border:1.5px solid #C8AA76;border-radius:6px;
    padding:6px 12px;font-family:'Lora',serif;font-size:12px;color:#5C3A18;
    cursor:pointer;transition:all .15s;display:flex;align-items:center;gap:5px;
  }
  .date-btn:hover{background:rgba(139,111,71,.12);border-color:var(--board-border)}
  .date-btn:active{transform:scale(.97)}
  .date-btn.active{border-color:var(--selected-ring);background:rgba(212,96,26,.1);box-shadow:0 0 0 1px rgba(212,96,26,.2)}
  .date-btn svg{width:14px;height:14px;stroke:#7A5C30;stroke-width:2;fill:none}
  .date-input-wrap{position:relative}
  .date-input{
    font-family:'Playfair Display',serif;font-size:14px;font-weight:600;color:#3A2A10;
    background:rgba(255,255,255,.6);border:1.5px solid #C8AA76;border-radius:6px;
    padding:6px 10px;text-align:center;cursor:pointer;min-width:150px;
  }
  .date-input:focus{outline:none;border-color:var(--selected-ring)}
  .date-input::-webkit-calendar-picker-indicator{cursor:pointer;opacity:.6}
  
  .game-area{display:flex;gap:18px;align-items:flex-start;flex-wrap:wrap;justify-content:center;width:100%}

  /* Stats */
  .stats-strip{display:none;width:100%;gap:6px;margin-bottom:10px}
  .stats-grid{display:grid;grid-template-columns:1fr 1fr 1fr;gap:5px;text-align:center}
  .stat-box{background:rgba(255,255,255,.5);border:1px solid #C8AA76;border-radius:6px;padding:8px 4px 6px}
  .stat-icon{font-size:15px;line-height:1;margin-bottom:3px}
  .stat-value{font-family:'Playfair Display',serif;font-size:1.1rem;color:#3A2A10;font-weight:600;line-height:1.1;margin-bottom:2px;min-height:1.3em}
  .stat-label{font-size:9px;color:#9A7040;letter-spacing:.05em;text-transform:uppercase}
  .stat-value.ticking{color:#2A6B4A}
  .stat-value.sol-low{color:#B55020}

  /* Board */
  .board-container{background:var(--board-bg);border:3px solid var(--board-border);border-radius:10px;padding:10px;
    box-shadow:0 8px 28px rgba(60,35,10,.22),inset 0 1px 0 rgba(255,255,255,.3);flex-shrink:0}
  .board{display:grid;grid-template-columns:repeat(7,var(--cs));grid-template-rows:repeat(8,var(--cs));gap:0}
  .cell{width:var(--cs);height:var(--cs);border:1px solid var(--cell-border);
    background:#fff;display:flex;align-items:center;justify-content:center;
    font-size:calc(var(--cs)*.2);font-weight:500;color:var(--cell-text);cursor:pointer;
    transition:background .12s;user-select:none;position:relative;overflow:hidden;touch-action:none}
  .cell.target-cell{box-shadow:inset 0 0 0 2.5px var(--target-color);animation:tp 2.4s ease-in-out infinite}
  @keyframes tp{
    0%,100%{box-shadow:inset 0 0 0 2.5px var(--target-color),0 0 0 0 rgba(212,176,23,0)}
    50%{box-shadow:inset 0 0 0 2.5px var(--target-color),0 0 6px 3px rgba(212,176,23,.28)}}
  .cell:hover:not(.inactive):not(.covered){background:#FFF8E8;z-index:2}
  .cell.inactive{visibility:hidden;pointer-events:none;border-color:transparent}
  .cell.covered{cursor:pointer}
  .cell.preview-valid{background:rgba(70,130,80,.3)!important;border-color:#4A7C59!important}
  .cell.preview-invalid{background:rgba(180,55,55,.2)!important;border-color:#B54040!important}
  .cell-piece-overlay{position:absolute;inset:0;opacity:0;transition:opacity .15s}
  .cell-piece-overlay.visible{opacity:.82}
  .cell-label{position:relative;z-index:2;pointer-events:none;font-weight:600}
  .cell.hint-flash .cell-piece-overlay{animation:hintFlash .9s ease-out forwards}
  @keyframes hintFlash{0%{opacity:1;filter:brightness(2.2)}40%{opacity:1;filter:brightness(1.5)}100%{opacity:.82;filter:brightness(1)}}

  /* Selected-on-board ring: placed but still selected */
  .cell.sel-placed-ring{box-shadow:inset 0 0 0 3px var(--selected-ring)!important;z-index:3}

  /* Drag ghost */
  #dragGhost{
    position:fixed;pointer-events:none;z-index:9999;
    display:none;transform-origin:top left;
    filter:drop-shadow(0 6px 18px rgba(0,0,0,.38));
    transition:filter .12s;
  }
  #dragGhost.visible{display:block}
  #dragGhost.floating{opacity:.72}   /* resting over board, not being dragged */
  #dragGhost.dragging{opacity:.88}
  #dragGhost.over-valid{filter:drop-shadow(0 6px 18px rgba(50,160,80,.55))}
  #dragGhost.over-invalid{filter:drop-shadow(0 6px 18px rgba(180,50,50,.5))}
  .ghost-grid{display:grid;gap:0}
  .ghost-cell{border-radius:2px}

  /* Sidebar */
  .sidebar{display:flex;flex-direction:column;gap:12px;width:220px}
  .panel{background:var(--board-bg);border:2px solid var(--board-border);border-radius:8px;
    padding:12px 14px;box-shadow:0 4px 14px rgba(60,35,10,.14)}
  .panel h3{font-family:'Playfair Display',serif;font-size:.95rem;color:#5C3A18;
    margin-bottom:10px;border-bottom:1px solid #C8AA76;padding-bottom:6px;letter-spacing:.02em}
  .pieces-tray{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .piece-wrapper{display:flex;flex-direction:column;align-items:center;justify-content:center;
    gap:3px;cursor:pointer;padding:6px 4px;border:2px solid transparent;border-radius:6px;
    transition:all .15s;min-height:56px;background:rgba(255,255,255,.35);touch-action:manipulation}
  .piece-wrapper:hover:not(.placed-away){background:rgba(139,111,71,.12);border-color:var(--board-border)}
  .piece-wrapper.selected{border-color:var(--selected-ring);background:rgba(212,96,26,.1);box-shadow:0 0 0 1px rgba(212,96,26,.3)}
  .piece-wrapper.placed-away{opacity:.28;cursor:default;filter:grayscale(.4)} /* placed, not selected */
  .piece-wrapper.placed-selected{opacity:.7;border-color:var(--selected-ring);background:rgba(212,96,26,.08)} /* placed AND selected */
  .piece-mini{display:grid;gap:0}
  .piece-mini-cell{width:13px;height:13px;border-radius:0;border:none}

  .ctrl-row{display:flex;gap:6px;margin-bottom:8px}
  .btn{background:#6B4820;color:#FAF7EF;border:none;border-radius:5px;padding:8px 10px;
    font-family:'Lora',serif;font-size:12px;cursor:pointer;transition:background .13s,transform .08s;
    flex:1;display:flex;align-items:center;justify-content:center;gap:4px;min-height:40px;touch-action:manipulation}
  .btn:hover{background:#8B6A3A;transform:translateY(-1px)}
  .btn:active{background:#4A3010;transform:none}
  .btn:disabled{opacity:.4;cursor:not-allowed;transform:none}
  .btn-hint{background:#2A6B4A;color:#FAF7EF}
  .btn-hint:hover{background:#3A8A60}
  .btn-hint:disabled{opacity:.4;cursor:not-allowed;transform:none}
  .btn-reset{background:transparent;color:#7A5230;border:2px solid #C8AA76;font-size:12px;
    width:100%;padding:7px;margin-top:2px;flex:none;min-height:40px}
  .btn-reset:hover{background:rgba(100,60,20,.08)}
  .kbd{display:inline-block;background:rgba(255,255,255,.2);border:1px solid rgba(255,255,255,.3);
    border-radius:3px;padding:0 4px;font-size:10px;font-family:monospace;line-height:1.4}
  .selected-info{font-size:11.5px;color:#5C3A18;text-align:center;font-style:italic;
    min-height:32px;display:flex;align-items:center;justify-content:center;margin-bottom:8px;line-height:1.4}
  .instructions{font-size:11.5px;color:#5C3A18;line-height:1.7}
  .instructions li{margin-left:14px}
  .solving-msg{display:none;font-size:11px;color:#7A5230;text-align:center;font-style:italic;margin-top:4px}
  .solving-msg.show{display:block}

  /* Mobile toolbar */
  .mobile-toolbar{display:none;width:100%;flex-direction:column;gap:8px;margin-top:10px}
  .mobile-selected{font-size:12px;color:#5C3A18;text-align:center;font-style:italic;min-height:20px;line-height:1.4;padding:2px 0}
  .mobile-btns{display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:6px}
  .mobile-btn{background:#6B4820;color:#FAF7EF;border:none;border-radius:8px;
    padding:0;height:48px;font-family:'Lora',serif;font-size:11px;cursor:pointer;
    display:flex;flex-direction:column;align-items:center;justify-content:center;gap:2px;
    touch-action:manipulation;transition:background .1s,transform .08s}
  .mobile-btn:active{background:#4A3010;transform:scale(.95)}
  .mobile-btn:disabled{opacity:.35;cursor:not-allowed;transform:none}
  .mobile-btn.green{background:#2A6B4A}
  .mobile-btn.green:active{background:#1A5038}
  .mobile-btn.outline{background:transparent;color:#7A5230;border:2px solid #C8AA76}
  .mobile-btn.outline:active{background:rgba(100,60,20,.12)}
  .mobile-btn-icon{font-size:18px;line-height:1}
  .mobile-btn-label{font-size:9px;letter-spacing:.03em;text-transform:uppercase;line-height:1}
  .mobile-solving{font-size:11px;color:#7A5230;text-align:center;font-style:italic;display:none;padding:2px 0}
  .mobile-solving.show{display:block}

  /* Mobile piece tray */
  .mobile-tray-wrap{display:none;width:100%;margin-top:8px}
  .mobile-tray-wrap .panel{padding:10px}
  .mobile-pieces-tray{display:grid;grid-template-columns:repeat(5,1fr);gap:6px}
  .mobile-pieces-tray .piece-wrapper{min-height:44px;padding:4px 2px}

  /* Win overlay */
  .win-overlay{position:fixed;inset:0;background:rgba(30,18,6,.72);display:none;
    align-items:center;justify-content:center;z-index:1000;animation:fadeIn .3s ease;padding:16px}
  .win-overlay.show{display:flex}
  @keyframes fadeIn{from{opacity:0}to{opacity:1}}
  .win-box{background:#FBF8F0;border:3px solid #7A5C30;border-radius:14px;
    padding:clamp(24px,5vw,40px) clamp(20px,6vw,46px);
    text-align:center;box-shadow:0 20px 60px rgba(0,0,0,.5);max-width:380px;width:100%;
    animation:popIn .35s cubic-bezier(.34,1.56,.64,1)}
  @keyframes popIn{from{transform:scale(.7);opacity:0}to{transform:scale(1);opacity:1}}
  .win-box h2{font-family:'Playfair Display',serif;font-size:clamp(1.4rem,6vw,2rem);color:#3A2A10;margin-bottom:8px}
  .win-box p{color:#7A5230;font-style:italic;font-size:.9rem;margin-bottom:6px;line-height:1.6}
  .win-date{font-family:'Playfair Display',serif;font-size:clamp(.95rem,3vw,1.25rem);color:#3A2A10;margin-bottom:6px;font-weight:600}
  .win-summary{display:flex;gap:12px;justify-content:center;margin:14px 0 20px}
  .win-stat{background:#F5EFE0;border:1px solid #C8AA76;border-radius:8px;padding:8px 14px;min-width:72px}
  .win-stat-val{font-family:'Playfair Display',serif;font-size:1.2rem;color:#3A2A10;font-weight:600}
  .win-stat-lbl{font-size:10px;color:#9A7040;text-transform:uppercase;letter-spacing:.05em}

  /* Mobile breakpoint */
  @media(max-width:620px){
    body{padding:10px 0 80px}
    h1{font-size:1.4rem}
    .subtitle{font-size:.75rem;margin-bottom:6px}
    .date-picker-row{margin-bottom:8px}
    .game-area{gap:0;flex-direction:column;align-items:center}
    .sidebar{display:none}
    .stats-strip{display:grid}
    .board-container{border-radius:0;border-left:none;border-right:none;padding:0;
      box-shadow:none;border-top:2px solid var(--board-border);border-bottom:2px solid var(--board-border)}
    .mobile-toolbar{display:flex}
    .mobile-tray-wrap{display:block}
    .stats-strip .stats-grid,.stats-strip{width:100%}
    .stats-strip{padding:0 12px}
  }
</style>
</head>
<body>

<div id="dragGhost"><div class="ghost-grid" id="ghostGrid"></div></div>

<div class="win-overlay" id="winOverlay">
  <div class="win-box">
    <h2>&#127881; Puzzle Solved!</h2>
    <div class="win-date" id="winDate"></div>
    <p>You've uncovered the date. Brilliant!</p>
    <div class="win-summary">
      <div class="win-stat"><div class="win-stat-val" id="winTime">—</div><div class="win-stat-lbl">Time</div></div>
      <div class="win-stat"><div class="win-stat-val" id="winMoves">—</div><div class="win-stat-lbl">Moves</div></div>
    </div>
    <button class="btn" style="margin:auto;max-width:160px;padding:10px 20px;font-size:14px;flex:none;min-height:44px" onclick="closeWin()">Keep Playing</button>
  </div>
</div>

<h1>Calendar Puzzle</h1>
<div class="subtitle" id="subtitleEl">Place all pieces to reveal today's date</div>

<div class="date-picker-row">
  <button class="date-btn" id="btnToday" onclick="setToday()">
    <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="4"/><path d="M12 2v2m0 16v2M2 12h2m16 0h2m-4.2-5.8 1.4-1.4M4.8 19.2l1.4-1.4m0-11.6L4.8 4.8m14.4 14.4-1.4-1.4"/></svg>
    Today
  </button>
  <div class="date-input-wrap">
    <input type="date" class="date-input" id="dateInput" onchange="onDateChange()">
  </div>
</div>

<div class="stats-strip">
  <div class="stats-grid" style="width:100%">
    <div class="stat-box"><div class="stat-icon">&#9201;</div><div class="stat-value" id="statTimeMob">0:00</div><div class="stat-label">Time</div></div>
    <div class="stat-box"><div class="stat-icon">&#127919;</div><div class="stat-value" id="statMovesMob">0</div><div class="stat-label">Moves</div></div>
    <div class="stat-box"><div class="stat-icon">&#128272;</div><div class="stat-value" id="statSolsMob">—</div><div class="stat-label">Solutions</div></div>
  </div>
</div>

<div class="game-area">
  <div class="board-container" id="boardContainer">
    <div class="board" id="board"></div>
  </div>
  <div class="sidebar">
    <div class="panel">
      <h3>Progress</h3>
      <div class="stats-grid">
        <div class="stat-box"><div class="stat-icon">&#9201;</div><div class="stat-value" id="statTime">0:00</div><div class="stat-label">Time</div></div>
        <div class="stat-box"><div class="stat-icon">&#127919;</div><div class="stat-value" id="statMoves">0</div><div class="stat-label">Moves</div></div>
        <div class="stat-box"><div class="stat-icon">&#128272;</div><div class="stat-value" id="statSolutions">—</div><div class="stat-label">Solutions</div></div>
      </div>
    </div>
    <div class="panel">
      <h3>Pieces <span id="progressText" style="font-family:Lora,serif;font-weight:400;font-size:.8rem;color:#9A7040"></span></h3>
      <div class="pieces-tray" id="piecesTray"></div>
    </div>
    <div class="panel">
      <h3>Controls</h3>
      <div class="selected-info" id="selectedInfo">&#8592; Select a piece to begin</div>
      <div class="ctrl-row">
        <button class="btn" id="btnRotate" onclick="rotateSelected()" disabled>&#8635; Rotate <span class="kbd">R</span></button>
        <button class="btn" id="btnFlip" onclick="flipSelected()" disabled>&#8660; Flip <span class="kbd">F</span></button>
      </div>
      <button class="btn btn-hint" id="btnHint" onclick="hintSelected()" disabled style="width:100%;margin-bottom:6px;flex:none">&#128161; Hint <span class="kbd">H</span></button>
      <div class="solving-msg" id="solvingMsg">Thinking&#8230;</div>
      <button class="btn btn-reset" onclick="resetGame()">&#8634; Reset Puzzle</button>
    </div>
    <div class="panel">
      <h3>How To Play</h3>
      <ol class="instructions">
        <li>Select a piece from the tray</li>
        <li>Rotate <b>(R)</b> or flip <b>(F)</b> it</li>
        <li>Click the board to place it</li>
        <li>Rotate/flip after placing to adjust</li>
        <li>Leave the <span style="color:#B8880A;font-weight:600">&#10022; gold-bordered</span> cells exposed!</li>
      </ol>
    </div>
  </div>
</div>

<div class="mobile-toolbar" id="mobileToolbar">
  <div class="mobile-selected" id="mobileSelectedInfo">Tap or drag a piece below</div>
  <div class="mobile-btns">
    <button class="mobile-btn" id="mbRotate" onclick="rotateSelected()" disabled>
      <span class="mobile-btn-icon">&#8635;</span><span class="mobile-btn-label">Rotate</span>
    </button>
    <button class="mobile-btn" id="mbFlip" onclick="flipSelected()" disabled>
      <span class="mobile-btn-icon">&#8660;</span><span class="mobile-btn-label">Flip</span>
    </button>
    <button class="mobile-btn green" id="mbHint" onclick="hintSelected()" disabled>
      <span class="mobile-btn-icon">&#128161;</span><span class="mobile-btn-label">Hint</span>
    </button>
    <button class="mobile-btn outline" onclick="resetGame()">
      <span class="mobile-btn-icon">&#8634;</span><span class="mobile-btn-label">Reset</span>
    </button>
  </div>
  <div class="mobile-solving" id="mobileSolvingMsg">Thinking&#8230;</div>
</div>

<div class="mobile-tray-wrap">
  <div class="panel">
    <h3>Pieces <span id="progressTextMob" style="font-family:Lora,serif;font-weight:400;font-size:.8rem;color:#9A7040"></span></h3>
    <div class="mobile-pieces-tray" id="piecesTrayMob"></div>
  </div>
</div>

<script>
const PIECE_DEFS=[
  {id:0,name:'A',color:'#C05A3A',cells:[[0,0],[0,1],[0,2],[1,0]]},
  {id:1,name:'B',color:'#4A7C59',cells:[[0,0],[0,1],[0,2],[1,1],[2,1]]},
  {id:2,name:'C',color:'#5B7FA8',cells:[[0,1],[0,2],[1,1],[2,0],[2,1]]},
  {id:3,name:'D',color:'#C9994C',cells:[[0,0],[0,1],[0,2],[0,3]]},
  {id:4,name:'E',color:'#8B7BA8',cells:[[0,2],[0,3],[1,0],[1,1],[1,2]]},
  {id:5,name:'F',color:'#B55020',cells:[[0,0],[0,1],[1,1],[2,1],[3,1]]},
  {id:6,name:'G',color:'#5C8A3A',cells:[[0,1],[0,2],[1,0],[1,1]]},
  {id:7,name:'H',color:'#3E6E9E',cells:[[0,0],[0,1],[0,2],[1,2],[2,2]]},
  {id:8,name:'I',color:'#A83040',cells:[[0,0],[0,2],[1,0],[1,1],[1,2]]},
  {id:9,name:'J',color:'#6B7C8C',cells:[[0,0],[0,1],[0,2],[1,0],[1,1]]},
];

// ─── Current target date ──────────────────────────────────────────────────────
let currentTargetDate = new Date();

// ─── Cell size ────────────────────────────────────────────────────────────────
function getCellSize(){
  return parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cs'))||52;
}
function setCellSize(){
  const avail=Math.min(window.innerWidth-40,420);
  const cs=Math.floor(avail/7);
  document.documentElement.style.setProperty('--cs',cs+'px');
}
setCellSize();
window.addEventListener('resize',setCellSize);

// ─── Helpers ──────────────────────────────────────────────────────────────────
function isActive(r,c){
  if(r===0||r===1) return c>=0&&c<6;
  if(r>=2&&r<=6)   return c>=0&&c<7;
  if(r===7)        return c>=4&&c<7;
  return false;
}
function getCellLabel(r,c){
  if(r===0) return['Jan','Feb','Mar','Apr','May','Jun'][c];
  if(r===1) return['Jul','Aug','Sep','Oct','Nov','Dec'][c];
  if(r>=2&&r<=5) return String((r-2)*7+c+1);
  if(r===6){if(c<=2) return String(29+c);return['Sun','Mon','Tue','Wed'][c-3];}
  if(r===7) return['Thu','Fri','Sat'][c-4];
  return'';
}
function computeTargets(date){
  const t = date || new Date();
  const mo=t.getMonth(),day=t.getDate(),dow=t.getDay();
  const mr=mo<6?0:1,mc=mo<6?mo:mo-6;
  let dr,dc;
  if(day<=28){dr=Math.floor((day-1)/7)+2;dc=(day-1)%7}else{dr=6;dc=day-29}
  let wr,wc;
  if(dow<=3){wr=6;wc=dow+3}else{wr=7;wc=dow}
  return[[mr,mc],[dr,dc],[wr,wc]];
}

let TARGET_CELLS=computeTargets(currentTargetDate);
let TARGET_SET=new Set(TARGET_CELLS.map(([r,c])=>`${r},${c}`));

function updateTargets(date){
  currentTargetDate = date;
  TARGET_CELLS = computeTargets(date);
  TARGET_SET = new Set(TARGET_CELLS.map(([r,c])=>`${r},${c}`));
  updateSubtitle();
  updateDatePickerUI();
}

function updateSubtitle(){
  const isToday = isSameDay(currentTargetDate, new Date());
  const dateStr = currentTargetDate.toLocaleDateString('en-US',{weekday:'long',month:'long',day:'numeric',year:'numeric'});
  const el = document.getElementById('subtitleEl');
  if(isToday){
    el.textContent = `Today is ${dateStr} — can you expose it?`;
  } else {
    el.textContent = `Can you expose ${dateStr}?`;
  }
}

function isSameDay(d1, d2){
  return d1.getFullYear()===d2.getFullYear() && d1.getMonth()===d2.getMonth() && d1.getDate()===d2.getDate();
}

function updateDatePickerUI(){
  const isToday = isSameDay(currentTargetDate, new Date());
  document.getElementById('btnToday').classList.toggle('active', isToday);
  // Format date for input (YYYY-MM-DD)
  const y = currentTargetDate.getFullYear();
  const m = String(currentTargetDate.getMonth()+1).padStart(2,'0');
  const d = String(currentTargetDate.getDate()).padStart(2,'0');
  document.getElementById('dateInput').value = `${y}-${m}-${d}`;
}

function setToday(){
  updateTargets(new Date());
  resetGame();
}

function onDateChange(){
  const val = document.getElementById('dateInput').value;
  if(!val) return;
  const parts = val.split('-');
  const date = new Date(parseInt(parts[0]), parseInt(parts[1])-1, parseInt(parts[2]));
  updateTargets(date);
  resetGame();
}

function normalize(cells){
  const minR=Math.min(...cells.map(([r])=>r)),minC=Math.min(...cells.map(([,c])=>c));
  return cells.map(([r,c])=>[r-minR,c-minC]);
}
function rotateCW(cells){return normalize(cells.map(([r,c])=>[c,-r]))}
function flipH(cells){return normalize(cells.map(([r,c])=>[r,-c]))}

// ─── Game state ───────────────────────────────────────────────────────────────
let pieces,boardPieces,cellEls=[];
let selectedPieceId=null; // stays set after placement until new piece chosen
let hoverCell=null;
let moveCount=0,timerStarted=false,timerSeconds=0,timerInterval=null,solComputeTimer=null;
// track anchor position of placed-selected piece so rotate/flip can re-anchor
let placedAnchor=null; // {ar, ac} of top-left of currently placed+selected piece

function initState(){
  pieces=PIECE_DEFS.map(p=>({...p,cells:p.cells.map(c=>[...c]),placed:false}));
  boardPieces=Array.from({length:8},()=>Array(7).fill(null));
  selectedPieceId=null; hoverCell=null; placedAnchor=null;
  moveCount=0;timerStarted=false;timerSeconds=0;
  if(timerInterval){clearInterval(timerInterval);timerInterval=null;}
  if(solComputeTimer){clearTimeout(solComputeTimer);solComputeTimer=null;}
  ghost.hide();
  updateAllStats();
}

// ─── Timer ────────────────────────────────────────────────────────────────────
function startTimerIfNeeded(){
  if(timerStarted) return;
  timerStarted=true;
  timerInterval=setInterval(()=>{
    timerSeconds++;
    const s=formatTime(timerSeconds);
    sv('statTime',s,'ticking');sv('statTimeMob',s,'ticking');
  },1000);
}
function stopTimer(){if(timerInterval){clearInterval(timerInterval);timerInterval=null;}}
function formatTime(s){return`${Math.floor(s/60)}:${(s%60).toString().padStart(2,'0')}`;}
function sv(id,text,cls=''){
  const el=document.getElementById(id);if(!el) return;
  el.textContent=text;el.className='stat-value'+(cls?' '+cls:'');
}
function updateAllStats(){
  const t=formatTime(timerSeconds);
  sv('statTime',t,timerStarted?'ticking':'');sv('statTimeMob',t,timerStarted?'ticking':'');
  sv('statMoves',String(moveCount));sv('statMovesMob',String(moveCount));
}

// ─── Solution counter ─────────────────────────────────────────────────────────
function cellsKey(cells){return cells.map(([r,c])=>`${r},${c}`).sort().join('|');}
function getOrientations(baseCells){
  const seen=new Set(),result=[];let cur=baseCells.map(c=>[...c]);
  for(let f=0;f<2;f++){
    for(let rot=0;rot<4;rot++){const n=normalize(cur),k=cellsKey(n);if(!seen.has(k)){seen.add(k);result.push(n)}cur=rotateCW(cur);}
    cur=flipH(cur);
  }
  return result;
}
const MAX_SOL=6,MAX_SOL_MS=400;
function countSolutions(board,remaining){
  let count=0,timedOut=false;
  const deadline=performance.now()+MAX_SOL_MS;
  function solve(rem){
    if(count>=MAX_SOL||timedOut) return;
    if((count&15)===0&&performance.now()>deadline){timedOut=true;return;}
    let fr=-1,fc=-1;
    outer:for(let r=0;r<8;r++) for(let c=0;c<7;c++) if(isActive(r,c)&&!TARGET_SET.has(`${r},${c}`)&&board[r][c]===null){fr=r;fc=c;break outer}
    if(fr===-1){if(TARGET_CELLS.every(([r,c])=>board[r][c]===null)) count++;return;}
    for(let i=0;i<rem.length;i++){
      if(count>=MAX_SOL||timedOut) return;
      const{id,orientations}=rem[i],rest=rem.filter((_,j)=>j!==i);
      for(const ori of orientations){
        if(count>=MAX_SOL||timedOut) return;
        for(const[dr,dc] of ori){
          if(count>=MAX_SOL||timedOut) return;
          const ar=fr-dr,ac=fc-dc;let ok=true;
          for(const[r2,c2] of ori){const r=ar+r2,c=ac+c2;if(r<0||r>=8||c<0||c>=7||!isActive(r,c)||board[r][c]!==null){ok=false;break}}
          if(!ok) continue;
          for(const[r2,c2] of ori) board[ar+r2][ac+c2]=id;
          solve(rest);
          for(const[r2,c2] of ori) board[ar+r2][ac+c2]=null;
        }
      }
    }
  }
  solve(remaining);return{count,timedOut};
}
function scheduleSolutionCount(){
  const placed=pieces.filter(p=>p.placed).length;
  if(placed===0){sv('statSolutions','—');sv('statSolsMob','—');return;}
  sv('statSolutions','…');sv('statSolsMob','…');
  if(solComputeTimer) clearTimeout(solComputeTimer);
  solComputeTimer=setTimeout(()=>{
    const board=boardPieces.map(row=>[...row]);
    const remaining=pieces.filter(p=>!p.placed).map(p=>({id:p.id,orientations:getOrientations(PIECE_DEFS[p.id].cells)}));
    const{count:n,timedOut}=countSolutions(board,remaining);
    const display=timedOut||n>=MAX_SOL?'>5':String(n);
    const cls=n<=3&&n>0&&!timedOut?'sol-low':'';
    sv('statSolutions',display,cls);sv('statSolsMob',display,cls);
  },40);
}

// ─── Ghost drag system ────────────────────────────────────────────────────────
// Two modes:
//   floating  – ghost visible at board center (after tapping tray), not being dragged
//   dragging  – finger down, ghost following touch
const ghost={
  visible:false,
  dragging:false,
  lastAr:null,lastAc:null,
  // Where within the ghost element the finger landed (so ghost doesn't jump on pickup)
  offsetX:0,offsetY:0,
  // Original anchor to restore on failed drop
  _savedAr:null,_savedAc:null,

  // Rebuild the ghost grid (called by refresh when piece shape changes)
  refresh(){
    if(!this.visible||selectedPieceId===null) return;
    this._buildGrid();
    // Re-center the ghost on the board
    const cs=getCellSize();
    const p=pieces[selectedPieceId];
    const rows=p.cells.map(([r])=>r),cols=p.cells.map(([,c])=>c);
    const maxR=Math.max(...rows),maxC=Math.max(...cols);
    const gw=(maxC+1)*cs,gh=(maxR+1)*cs;
    const boardEl=document.getElementById('board');
    const rect=boardEl.getBoundingClientRect();
    const x=rect.left+(rect.width-gw)/2;
    const y=rect.top+(rect.height-gh)/2;
    const el=document.getElementById('dragGhost');
    el.style.left=x+'px';el.style.top=y+'px';
    // Update offset for new shape
    this.offsetX=cs*0.5;this.offsetY=cs*0.5;
  },

  // Show ghost centered on the board (called when piece is selected via tap from tray)
  showAtBoard(){
    if(selectedPieceId===null) return;
    this._buildGrid();
    const cs=getCellSize();
    const p=pieces[selectedPieceId];
    const rows=p.cells.map(([r])=>r),cols=p.cells.map(([,c])=>c);
    const maxR=Math.max(...rows),maxC=Math.max(...cols);
    const gw=(maxC+1)*cs,gh=(maxR+1)*cs;
    const boardEl=document.getElementById('board');
    const rect=boardEl.getBoundingClientRect();
    const x=rect.left+(rect.width-gw)/2;
    const y=rect.top+(rect.height-gh)/2;
    const el=document.getElementById('dragGhost');
    el.style.left=x+'px';el.style.top=y+'px';
    el.className='visible floating';
    this.visible=true;this.dragging=false;
    this.lastAr=null;this.lastAc=null;
    // Default offset: finger relative to top-left of ghost = half a cell
    this.offsetX=cs*0.5;this.offsetY=cs*0.5;
  },

  // Place ghost exactly over a board anchor cell, ready to drag.
  // touchX/touchY = finger screen coords at the moment of pickup.
  showAtCell(ar,ac,touchX,touchY){
    if(selectedPieceId===null) return;
    this._buildGrid();
    // Find the top-left corner of the anchor cell in screen coords
    const cellEl=cellEls[ar][ac];
    const rect=cellEl.getBoundingClientRect();
    const el=document.getElementById('dragGhost');
    el.style.left=rect.left+'px';
    el.style.top=rect.top+'px';
    el.className='visible dragging';
    this.visible=true;this.dragging=true;
    this.lastAr=ar;this.lastAc=ac;
    // Offset = where finger landed relative to ghost top-left
    this.offsetX=touchX-rect.left;
    this.offsetY=touchY-rect.top;
  },

  startDrag(clientX,clientY){
    if(!this.visible||selectedPieceId===null) return;
    this.dragging=true;
    this._moveTo(clientX,clientY);
    document.getElementById('dragGhost').className='visible dragging';
  },

  move(clientX,clientY){
    if(!this.dragging) return;
    this._moveTo(clientX,clientY);
    const{ar,ac}=this._boardCellAt(clientX,clientY);
    this.lastAr=ar;this.lastAc=ac;
    const el=document.getElementById('dragGhost');
    if(ar!==null){
      const valid=isValidPlacement(selectedPieceId,ar,ac);
      el.className='visible dragging '+(valid?'over-valid':'over-invalid');
      refreshBoard(ar,ac);
    } else {
      el.className='visible dragging';
      refreshBoard();
    }
  },

  endDrag(){
    if(!this.dragging) return;
    this.dragging=false;
    const ar=this.lastAr,ac=this.lastAc;
    if(ar!==null&&selectedPieceId!==null&&!pieces[selectedPieceId].placed&&isValidPlacement(selectedPieceId,ar,ac)){
      recordPlacement(ar,ac);
      placePiece(selectedPieceId,ar,ac);
      this.hide();
      buildAllTrays();updateControls();refreshBoard();checkWin();scheduleSolutionCount();
    } else {
      // Failed drop — restore to original position if we have one
      if(this._savedAr!==null&&selectedPieceId!==null&&!pieces[selectedPieceId].placed){
        placePiece(selectedPieceId,this._savedAr,this._savedAc);
        placedAnchor={ar:this._savedAr,ac:this._savedAc};
        this._savedAr=null;this._savedAc=null;
        buildAllTrays();updateControls();refreshBoard();
        this.hide();
        scheduleSolutionCount();
      } else {
        this.showAtBoard();
        refreshBoard();
      }
    }
  },

  hide(){
    document.getElementById('dragGhost').className='';
    this.visible=false;this.dragging=false;
    this.lastAr=null;this.lastAc=null;
    this._savedAr=null;this._savedAc=null;
  },

  _buildGrid(){
    if(selectedPieceId===null) return;
    const p=pieces[selectedPieceId];
    const cs=getCellSize();
    const rows=p.cells.map(([r])=>r),cols=p.cells.map(([,c])=>c);
    const maxR=Math.max(...rows),maxC=Math.max(...cols);
    const cellSet=new Set(p.cells.map(([r,c])=>`${r},${c}`));
    const grid=document.getElementById('ghostGrid');
    grid.innerHTML='';
    grid.style.gridTemplateColumns=`repeat(${maxC+1},${cs}px)`;
    grid.style.gridTemplateRows=`repeat(${maxR+1},${cs}px)`;
    for(let r=0;r<=maxR;r++){
      for(let c=0;c<=maxC;c++){
        const cell=document.createElement('div');
        cell.style.width=cs+'px';cell.style.height=cs+'px';
        if(cellSet.has(`${r},${c}`)){cell.className='ghost-cell';cell.style.background=p.color;cell.style.opacity='0.85';}
        grid.appendChild(cell);
      }
    }
  },

  // Move ghost so the finger is at (offsetX, offsetY) within it
  _moveTo(clientX,clientY){
    const el=document.getElementById('dragGhost');
    el.style.left=(clientX-this.offsetX)+'px';
    el.style.top=(clientY-this.offsetY)+'px';
  },

  _boardCellAt(clientX,clientY){
    const el=document.getElementById('dragGhost');
    const prev=el.style.display;el.style.display='none';
    const target=document.elementFromPoint(clientX,clientY);
    el.style.display=prev;
    if(!target) return{ar:null,ac:null};
    let t=target;
    while(t&&!t._cellCoords) t=t.parentElement;
    if(t&&t._cellCoords){const{r,c}=t._cellCoords;return{ar:r,ac:c};}
    return{ar:null,ac:null};
  }
};

// Document-level touch handlers
document.addEventListener('touchmove',e=>{
  if(!ghost.dragging) return;
  e.preventDefault();
  ghost.move(e.touches[0].clientX,e.touches[0].clientY);
},{passive:false});

document.addEventListener('touchend',e=>{
  if(!ghost.dragging) return;
  e.preventDefault();
  ghost.endDrag();
},{passive:false});

document.addEventListener('touchcancel',()=>{
  if(!ghost.dragging) return;
  ghost.dragging=false;
  // Restore to original board position if available
  if(ghost._savedAr!==null&&selectedPieceId!==null&&!pieces[selectedPieceId].placed){
    placePiece(selectedPieceId,ghost._savedAr,ghost._savedAc);
    placedAnchor={ar:ghost._savedAr,ac:ghost._savedAc};
    ghost.hide();
    buildAllTrays();updateControls();refreshBoard();scheduleSolutionCount();
  } else {
    ghost.showAtBoard();
    refreshBoard();
  }
});

// Touching the board area while ghost is floating starts the drag
document.getElementById('boardContainer').addEventListener('touchstart',e=>{
  if(ghost.visible&&!ghost.dragging&&selectedPieceId!==null&&!pieces[selectedPieceId].placed){
    e.preventDefault();
    ghost.startDrag(e.touches[0].clientX,e.touches[0].clientY);
  }
},{passive:false});

// ─── Board rendering ──────────────────────────────────────────────────────────
function buildBoard(){
  const boardEl=document.getElementById('board');
  boardEl.innerHTML='';cellEls=[];
  for(let r=0;r<8;r++){
    cellEls[r]=[];
    for(let c=0;c<7;c++){
      const cell=document.createElement('div');
      cell.className='cell';cellEls[r][c]=cell;
      if(!isActive(r,c)){
        cell.classList.add('inactive');
      } else {
        cell._cellCoords={r,c};
        if(TARGET_SET.has(`${r},${c}`)) cell.classList.add('target-cell');
        const ov=document.createElement('div');ov.className='cell-piece-overlay';cell.appendChild(ov);
        const lb=document.createElement('span');lb.className='cell-label';lb.textContent=getCellLabel(r,c);cell.appendChild(lb);
        cell.addEventListener('mouseenter',()=>{hoverCell={r,c};refreshBoard()});
        cell.addEventListener('mouseleave',()=>{hoverCell=null;refreshBoard()});
        cell.addEventListener('click',()=>onCellClick(r,c));
        cell.addEventListener('touchstart',e=>onCellTouchStart(r,c,e),{passive:false});
      }
      boardEl.appendChild(cell);
    }
  }
}

function refreshBoard(previewAr,previewAc){
  const pid=selectedPieceId;
  const placedCells=pid!==null&&pieces[pid].placed?
    new Set(pieces[pid].cells.map(([dr,dc])=>{
      // find where this piece is on the board
      for(let r=0;r<8;r++) for(let c=0;c<7;c++) if(boardPieces[r][c]===pid) return`${r},${c}`;
      return'';
    })):new Set();

  // Actually, build set of board coords occupied by selected-placed piece
  const selPlacedCoords=new Set();
  if(pid!==null&&pieces[pid].placed){
    for(let r=0;r<8;r++) for(let c=0;c<7;c++) if(boardPieces[r][c]===pid) selPlacedCoords.add(`${r},${c}`);
  }

  for(let r=0;r<8;r++){
    for(let c=0;c<7;c++){
      if(!isActive(r,c)) continue;
      const cell=cellEls[r][c];
      const ov=cell.querySelector('.cell-piece-overlay');
      const occupant=boardPieces[r][c];
      
      // Update target-cell class based on current TARGET_SET
      cell.classList.toggle('target-cell', TARGET_SET.has(`${r},${c}`));
      
      if(occupant!==null){
        ov.style.background=pieces[occupant].color;ov.classList.add('visible');cell.classList.add('covered');
      } else {
        ov.classList.remove('visible');cell.classList.remove('covered');
      }
      cell.classList.remove('preview-valid','preview-invalid','sel-placed-ring');
      // Highlight cells of placed+selected piece
      if(selPlacedCoords.has(`${r},${c}`)) cell.classList.add('sel-placed-ring');
    }
  }
  // Mouse hover preview (no active drag)
  if(!ghost.dragging&&pid!==null&&!pieces[pid].placed&&hoverCell!==null){
    const{r:ar,c:ac}=hoverCell;
    const valid=isValidPlacement(pid,ar,ac);
    const cls=valid?'preview-valid':'preview-invalid';
    for(const[dr,dc] of pieces[pid].cells){
      const r=ar+dr,c=ac+dc;
      if(r>=0&&r<8&&c>=0&&c<7&&isActive(r,c)) cellEls[r][c].classList.add(cls);
    }
  }
  // Drag ghost board preview
  if(ghost.dragging&&previewAr!==undefined&&pid!==null&&!pieces[pid].placed){
    const valid=isValidPlacement(pid,previewAr,previewAc);
    const cls=valid?'preview-valid':'preview-invalid';
    for(const[dr,dc] of pieces[pid].cells){
      const r=previewAr+dr,c=previewAc+dc;
      if(r>=0&&r<8&&c>=0&&c<7&&isActive(r,c)) cellEls[r][c].classList.add(cls);
    }
  }
}

// ─── Tray builder ─────────────────────────────────────────────────────────────
function buildOneTray(containerId,progressId,isMobile){
  const tray=document.getElementById(containerId);if(!tray) return;
  tray.innerHTML='';
  let placedCount=0;
  for(let i=0;i<pieces.length;i++){
    const p=pieces[i];
    if(p.placed) placedCount++;
    const wrap=document.createElement('div');
    wrap.className='piece-wrapper';
    const isSelected=selectedPieceId===i;
    if(p.placed&&isSelected) wrap.classList.add('placed-selected');
    else if(p.placed) wrap.classList.add('placed-away');
    else if(isSelected) wrap.classList.add('selected');

    const rows=p.cells.map(([r])=>r),cols2=p.cells.map(([,c])=>c);
    const maxR=Math.max(...rows),maxC=Math.max(...cols2);
    const cs=new Set(p.cells.map(([r,c])=>`${r},${c}`));
    const mg=document.createElement('div');
    mg.className='piece-mini';
    mg.style.gridTemplateColumns=`repeat(${maxC+1},13px)`;
    mg.style.gridTemplateRows=`repeat(${maxR+1},13px)`;
    mg.style.display='grid';
    for(let r=0;r<=maxR;r++){
      for(let c=0;c<=maxC;c++){
        const mc=document.createElement('div');
        if(cs.has(`${r},${c}`)){mc.className='piece-mini-cell';mc.style.background=p.color;}
        else{mc.style.width='13px';mc.style.height='13px';}
        mg.appendChild(mc);
      }
    }
    wrap.appendChild(mg);

    // Click: select (or deselect if already selected and unplaced)
    wrap.addEventListener('click',e=>{
      if(ghost.dragging) return;
      startTimerIfNeeded();
      if(selectedPieceId===i&&!pieces[i].placed){
        // deselect
        selectedPieceId=null;placedAnchor=null;ghost.hide();
      } else {
        // If piece was placed and currently selected, clicking it again deselects
        if(selectedPieceId===i&&pieces[i].placed){selectedPieceId=null;placedAnchor=null;ghost.hide();}
        else{selectPiece(i);}
      }
      buildAllTrays();updateControls();refreshBoard();
    });

    // Mobile: touchstart on tray piece → select + show ghost at board center
    if(isMobile){
      wrap.addEventListener('touchstart',e=>{
        e.preventDefault();
        startTimerIfNeeded();
        selectPiece(i);
        buildAllTrays();updateControls();refreshBoard();
        // show ghost centered on board; user then touches board to drag
        ghost.showAtBoard();
      },{passive:false});
    }

    tray.appendChild(wrap);
  }
  const prog=document.getElementById(progressId);if(prog) prog.textContent=`(${placedCount}/10)`;
}
function buildAllTrays(){
  buildOneTray('piecesTray','progressText',false);
  buildOneTray('piecesTrayMob','progressTextMob',true);
}

// Select a piece — if it's placed, pull it off the board first
function selectPiece(i){
  if(selectedPieceId===i) return; // already selected, nothing to do
  if(pieces[i].placed){
    removePiece(i);
    scheduleSolutionCount();
  }
  selectedPieceId=i;
  placedAnchor=null;
}

// ─── Controls ─────────────────────────────────────────────────────────────────
function updateControls(){
  const has=selectedPieceId!==null; // enabled whether placed or not
  ['btnRotate','btnFlip','btnHint'].forEach(id=>{const el=document.getElementById(id);if(el) el.disabled=!has;});
  const info=document.getElementById('selectedInfo');
  if(info){
    if(!has) info.textContent='\u2190 Select a piece to begin';
    else if(pieces[selectedPieceId].placed) info.textContent=`Piece ${pieces[selectedPieceId].name} placed \u2022 rotate/flip to adjust`;
    else info.textContent=`Piece ${pieces[selectedPieceId].name} selected \u2022 click board to place`;
  }
  ['mbRotate','mbFlip','mbHint'].forEach(id=>{const el=document.getElementById(id);if(el) el.disabled=!has;});
  const minfo=document.getElementById('mobileSelectedInfo');
  if(minfo){
    if(!has) minfo.textContent='Tap or drag a piece below';
    else if(pieces[selectedPieceId].placed) minfo.textContent=`Piece ${pieces[selectedPieceId].name} placed \u2022 rotate/flip to adjust`;
    else minfo.textContent=`Piece ${pieces[selectedPieceId].name} \u2014 drag or tap board to place`;
  }
}

// ─── Rotate / Flip ────────────────────────────────────────────────────────────
// Compute the board centroid of a placed piece
function placedCentroid(pid){
  const boardCells=[];
  for(let r=0;r<8;r++) for(let c=0;c<7;c++) if(boardPieces[r][c]===pid) boardCells.push([r,c]);
  if(!boardCells.length) return null;
  const avgR=boardCells.reduce((s,[r])=>s+r,0)/boardCells.length;
  const avgC=boardCells.reduce((s,[,c])=>s+c,0)/boardCells.length;
  return{r:avgR,c:avgC};
}

// Find the anchor that places the new cells' centroid nearest to (targetR, targetC).
// Searches a radius of a few cells to find the first valid placement.
function bestAnchorNearCentroid(pid,newCells,targetR,targetC){
  const avgDr=newCells.reduce((s,[r])=>s+r,0)/newCells.length;
  const avgDc=newCells.reduce((s,[,c])=>s+c,0)/newCells.length;
  const baseAr=Math.round(targetR-avgDr);
  const baseAc=Math.round(targetC-avgDc);
  // Search spiral outward from ideal position
  for(let radius=0;radius<=3;radius++){
    for(let dr=-radius;dr<=radius;dr++){
      for(let dc=-radius;dc<=radius;dc++){
        if(Math.abs(dr)!==radius&&Math.abs(dc)!==radius) continue; // only perimeter
        const ar=baseAr+dr,ac=baseAc+dc;
        if(isValidPlacement(pid,ar,ac)) return{ar,ac};
      }
    }
  }
  return null;
}

function applyTransformToPlaced(pid,transformFn){
  const centroid=placedCentroid(pid);
  removePiece(pid);
  pieces[pid].cells=transformFn(pieces[pid].cells);
  const anchor=centroid?bestAnchorNearCentroid(pid,pieces[pid].cells,centroid.r,centroid.c):null;
  if(anchor){
    placePiece(pid,anchor.ar,anchor.ac);
    placedAnchor=anchor;
    scheduleSolutionCount();
    buildAllTrays();updateControls();refreshBoard();ghost.hide();
  } else {
    // No valid spot — leave unplaced, show floating ghost
    scheduleSolutionCount();
    buildAllTrays();updateControls();refreshBoard();ghost.showAtBoard();
  }
}

function rotateSelected(){
  if(selectedPieceId===null) return;
  const pid=selectedPieceId;
  if(pieces[pid].placed){
    applyTransformToPlaced(pid,rotateCW);
  } else {
    pieces[pid].cells=rotateCW(pieces[pid].cells);
    ghost.refresh();buildAllTrays();refreshBoard();
  }
}
function flipSelected(){
  if(selectedPieceId===null) return;
  const pid=selectedPieceId;
  if(pieces[pid].placed){
    applyTransformToPlaced(pid,flipH);
  } else {
    pieces[pid].cells=flipH(pieces[pid].cells);
    ghost.refresh();buildAllTrays();refreshBoard();
  }
}

// ─── Solver ───────────────────────────────────────────────────────────────────
function solveBoard(board,remaining){
  let fr=-1,fc=-1;
  outer:for(let r=0;r<8;r++) for(let c=0;c<7;c++) if(isActive(r,c)&&!TARGET_SET.has(`${r},${c}`)&&board[r][c]===null){fr=r;fc=c;break outer}
  if(fr===-1) return TARGET_CELLS.every(([r,c])=>board[r][c]===null)?[]:null;
  for(let i=0;i<remaining.length;i++){
    const{id,orientations}=remaining[i],rest=remaining.filter((_,j)=>j!==i);
    for(const ori of orientations){
      for(const[dr,dc] of ori){
        const ar=fr-dr,ac=fc-dc;let ok=true;
        for(const[r2,c2] of ori){const r=ar+r2,c=ac+c2;if(r<0||r>=8||c<0||c>=7||!isActive(r,c)||board[r][c]!==null){ok=false;break}}
        if(!ok) continue;
        for(const[r2,c2] of ori) board[ar+r2][ac+c2]=id;
        const sub=solveBoard(board,rest);
        if(sub!==null) return[{id,ar,ac,cells:ori},...sub];
        for(const[r2,c2] of ori) board[ar+r2][ac+c2]=null;
      }
    }
  }
  return null;
}
function showSolvingMsg(t){['solvingMsg','mobileSolvingMsg'].forEach(id=>{const el=document.getElementById(id);if(el){el.textContent=t;el.classList.add('show');}});}
function hideSolvingMsg(){['solvingMsg','mobileSolvingMsg'].forEach(id=>{const el=document.getElementById(id);if(el) el.classList.remove('show');});}
function hintSelected(){
  if(selectedPieceId===null) return;
  const pid=selectedPieceId;
  // If piece is placed, un-place it first for solving
  if(pieces[pid].placed){removePiece(pid);scheduleSolutionCount();}
  showSolvingMsg('Thinking\u2026');
  ['btnHint','mbHint'].forEach(id=>{const el=document.getElementById(id);if(el) el.disabled=true;});
  setTimeout(()=>{
    const board=boardPieces.map(row=>[...row]);
    const remaining=pieces.filter(p=>!p.placed).map(p=>({id:p.id,orientations:getOrientations(PIECE_DEFS[p.id].cells)}));
    const solution=solveBoard(board,remaining);
    hideSolvingMsg();
    if(!solution){showSolvingMsg('No solution here \u2014 try removing a piece!');setTimeout(hideSolvingMsg,3000);updateControls();buildAllTrays();refreshBoard();ghost.showAtBoard();return;}
    const placement=solution.find(s=>s.id===pid);
    if(!placement){updateControls();buildAllTrays();refreshBoard();ghost.showAtBoard();return;}
    pieces[pid].cells=placement.cells;
    recordPlacement(placement.ar,placement.ac);
    placePiece(pid,placement.ar,placement.ac);
    for(const[dr,dc] of placement.cells){
      const cell=cellEls[placement.ar+dr][placement.ac+dc];
      cell.classList.add('hint-flash');setTimeout(()=>cell.classList.remove('hint-flash'),1000);
    }
    // Keep selected after hint
    buildAllTrays();updateControls();refreshBoard();checkWin();scheduleSolutionCount();
    ghost.hide();
  },30);
}

// ─── Placement ────────────────────────────────────────────────────────────────
function recordPlacement(ar,ac){
  startTimerIfNeeded();moveCount++;
  sv('statMoves',String(moveCount));sv('statMovesMob',String(moveCount));
  placedAnchor={ar,ac};
}
function isValidPlacement(pid,ar,ac){
  for(const[dr,dc] of pieces[pid].cells){
    const r=ar+dr,c=ac+dc;
    if(r<0||r>=8||c<0||c>=7||!isActive(r,c)||boardPieces[r][c]!==null) return false;
  }
  return true;
}
function placePiece(pid,ar,ac){
  for(const[dr,dc] of pieces[pid].cells) boardPieces[ar+dr][ac+dc]=pid;
  pieces[pid].placed=true;
}
function removePiece(pid){
  for(let r=0;r<8;r++) for(let c=0;c<7;c++) if(boardPieces[r][c]===pid) boardPieces[r][c]=null;
  pieces[pid].placed=false;
  placedAnchor=null;
}

// Click on a board cell
function onCellClick(r,c){
  if(ghost.dragging) return;
  const occ=boardPieces[r][c];
  if(selectedPieceId!==null&&!pieces[selectedPieceId].placed){
    if(isValidPlacement(selectedPieceId,r,c)){
      recordPlacement(r,c);
      placePiece(selectedPieceId,r,c);
      // Stay selected
      buildAllTrays();updateControls();refreshBoard();checkWin();scheduleSolutionCount();
      ghost.hide(); // piece is now placed; ring on board shows it's still selected
    }
  } else if(occ!==null){
    // Pick up piece from board
    const prev=selectedPieceId;
    if(prev!==null&&prev!==occ&&pieces[prev].placed){removePiece(prev);}
    removePiece(occ);
    selectedPieceId=occ;placedAnchor=null;
    buildAllTrays();updateControls();refreshBoard();scheduleSolutionCount();
  } else if(selectedPieceId!==null&&pieces[selectedPieceId].placed){
    // Click empty cell while piece is placed+selected — deselect
    selectedPieceId=null;placedAnchor=null;ghost.hide();
    buildAllTrays();updateControls();refreshBoard();
  }
}

// Touch on a board cell (pick up placed piece)
function onCellTouchStart(r,c,e){
  const occ=boardPieces[r][c];
  if(occ!==null){
    e.preventDefault();
    startTimerIfNeeded();
    if(selectedPieceId!==null&&selectedPieceId!==occ&&pieces[selectedPieceId]?.placed) removePiece(selectedPieceId);
    // Find the top-left anchor of this piece on the board (min row/col among its cells)
    let minR=8,minC=7;
    for(let pr=0;pr<8;pr++) for(let pc=0;pc<7;pc++) if(boardPieces[pr][pc]===occ){if(pr<minR||(pr===minR&&pc<minC)){minR=pr;minC=pc;}}
    // Save anchor so a failed drop can restore the piece in place
    ghost._savedAr=minR;ghost._savedAc=minC;
    removePiece(occ);
    selectedPieceId=occ;placedAnchor=null;
    buildAllTrays();updateControls();refreshBoard();scheduleSolutionCount();
    // Position ghost exactly over where the piece was, finger offset preserved
    ghost.showAtCell(minR,minC,e.touches[0].clientX,e.touches[0].clientY);
  } else if(ghost.visible&&!ghost.dragging&&selectedPieceId!==null&&!pieces[selectedPieceId].placed){
    // Touch empty cell while ghost floating — start drag
    e.preventDefault();
    ghost.startDrag(e.touches[0].clientX,e.touches[0].clientY);
  }
}

// ─── Win ──────────────────────────────────────────────────────────────────────
function checkWin(){
  const unc=[];
  for(let r=0;r<8;r++) for(let c=0;c<7;c++) if(isActive(r,c)&&boardPieces[r][c]===null) unc.push(`${r},${c}`);
  if(unc.length!==3) return;
  if(unc.every(k=>TARGET_SET.has(k))){
    stopTimer();ghost.hide();
    document.getElementById('winDate').textContent=currentTargetDate.toLocaleDateString('en-US',{weekday:'long',year:'numeric',month:'long',day:'numeric'});
    document.getElementById('winTime').textContent=formatTime(timerSeconds);
    document.getElementById('winMoves').textContent=String(moveCount);
    document.getElementById('winOverlay').classList.add('show');
  }
}
function closeWin(){document.getElementById('winOverlay').classList.remove('show');}
function resetGame(){stopTimer();initState();buildBoard();buildAllTrays();updateControls();refreshBoard();}

// ─── Keyboard ─────────────────────────────────────────────────────────────────
document.addEventListener('keydown',e=>{
  if(e.key==='r'||e.key==='R') rotateSelected();
  if(e.key==='f'||e.key==='F') flipSelected();
  if(e.key==='h'||e.key==='H') hintSelected();
  if(e.key==='Escape'){selectedPieceId=null;placedAnchor=null;ghost.hide();buildAllTrays();updateControls();refreshBoard();}
});

// ─── Init ─────────────────────────────────────────────────────────────────────
(function(){
  currentTargetDate = new Date();
  updateSubtitle();
  updateDatePickerUI();
  initState();buildBoard();buildAllTrays();updateControls();refreshBoard();
})();
</script>
</body>
</html>
